/*****************************************************************************
 *                        Web3d.org Copyright (c) 2004-2009
 *                               Java Source
 *
 * This source is licensed under the GNU LGPL v2.1
 * Please read http://www.gnu.org/copyleft/lgpl.html for more information
 *
 * This software comes with the standard NO WARRANTY disclaimer for any
 * purpose. Use it at your own risk. If there's a problem you get to fix it.
 *
 ****************************************************************************/
package org.web3d.vrml.renderer.common.input.dis;

// External imports
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.MulticastSocket;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.vecmath.Quat4f;

// Local imports
import edu.nps.moves.dis.*;
import edu.nps.moves.disenum.PduType;
import edu.nps.moves.net.BehaviorConsumerIF;
import edu.nps.moves.net.BehaviorProducerUDP;
import java.io.IOException;
import java.net.SocketException;
import java.net.UnknownHostException;

import org.web3d.vrml.nodes.VRMLDISManagerNodeType;
import org.web3d.vrml.nodes.VRMLDISNodeType;
import org.web3d.vrml.nodes.VRMLNetworkInterfaceNodeType;

/**
 * Network connection handler for native DIS protocol
 * @version $Id: DISConnectionHandler.java,v 1.3 2009-09-16 00:30:37 tbnorbra Exp $
 * @author <a href="mailto:tdnorbra@nps.edu">Terry Norbraten</a>
 */
public class DISConnectionHandler implements BehaviorConsumerIF {

    /**
     * The default order.
     */
    private static final int DEFAULT_ORDER = 2;

    /**
     * The default convergence interval.
     */
    private static final int DEFAULT_CONVERGENCE_INTERVAL = 200;

    BehaviorProducerUDP writer;

    DatagramSocket socket;

    InetAddress address;

    Thread readThread;

    private int port;

    private String group;

    int cnt;

    private LinkedList liveList;

    // Scratch id to avoid gc
    private DISId disId;

    // Scratch translation field
    private float[] translation;

    // Scratch rotation field
    private float[] rotation;

    private float[] dRorientation;

    private Quat4f quaternion = null;

    /** The node to ID mapping */
    private Map<DISId, NodeMapEntry> nodeMap;

    /** The list of managers */
    private List<VRMLDISNodeType> managerList;

    /** The Entities we've placed on the addedEntities */
    private Set<DISId> notifiedSet;

    /**
     *
     * @param nodeMap
     * @param liveList
     * @param managerList
     * @param notifiedSet
     * @param group
     * @param port
     */
    public DISConnectionHandler(Map<DISId, NodeMapEntry> nodeMap, LinkedList liveList, List<VRMLDISNodeType> managerList, Set<DISId> notifiedSet, String group, int port) {
        this.nodeMap = nodeMap;
        this.group = group;
        this.port = port;
        this.liveList = liveList;
        this.managerList = managerList;
        this.notifiedSet = notifiedSet;

        disId = new DISId(0, 0, 0);
        translation = new float[3];
        rotation = new float[4];
        dRorientation = new float[3];
        quaternion = new Quat4f();

        try {
            address = InetAddress.getByName(group);

            try {
                socket = new MulticastSocket(port);
                ((MulticastSocket) socket).joinGroup(address);
            } catch (IOException e) {
                System.err.println("Failed to listen to multicast port.  Trying unicast");
                if (socket != null)
                    socket.close();
                socket = new DatagramSocket(port);
            }
            System.out.println("DIS Listening to port: " + port + " group: " + group);

            writer = new BehaviorProducerUDP(socket);
            writer.setUseCopies(false);
            writer.setDefaultDestination(address, port);
            readThread = new Thread(writer);

            // Allow the JVM to shutdown if the browser window is closed
            readThread.setDaemon(true);
            readThread.start();
            writer.addListener(DISConnectionHandler.this);
        } catch (UnknownHostException | SocketException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Get a writer for this connection.
     *
     * @return The writer.
     */
    public BehaviorProducerUDP getWriter() {
        return writer;
    }

    //----------------------------------------------------------
    // Methods required by BehaviorConsumerIF
    //----------------------------------------------------------
    /**
     * Receives a PDU from the BehaviorProducer.
     *
     * @param pdu the Pdu generated by the BehaviorProducer
     */
    @Override
    public void receivePdu(Pdu pdu) {
        cnt++;

        if (cnt % 100 == 0) {
//            System.out.println("Packets received: " + cnt);
        }

        int type = pdu.getPduType();
        EntityID eid;
        NodeMapEntry entry;
        VRMLDISNodeType di;
        long time;
        long timestamp;
        PduType pduType = PduType.lookup[type];
        switch (pduType) {
//            case PduType.FIREFI:
            case FIRE:
                FirePdu firepdu = (FirePdu) pdu;

                eid = firepdu.getTargetEntityID();
                disId.setValue(eid.getSite(), eid.getApplication(), eid.getEntity());

                entry = nodeMap.get(disId);

                if (entry == null) {
                    //System.out.println("Unknown espdu: " + disId);
                    return;
                }

                di = entry.node;

                if (di.getRole() != VRMLNetworkInterfaceNodeType.ROLE_READER) {
                    // Ignore for non readers
                    return;
                }

                time = System.currentTimeMillis();
                timestamp = pdu.getTimestamp();
                if (di != null) {
                    if (entry.listEntry != null) {
                        // update last time
                        LiveListEntry lle = (LiveListEntry) entry.listEntry;

                        if (timestamp > lle.espduTimestamp) {
                            lle.avgTime = lle.avgTime + (time - lle.lastTime) / 5.0f;
                            lle.lastTime = time;
                            if (lle.currEspdu != null) {
                                lle.lastEspdu = lle.currEspdu;
                            }
                            lle.currFire = firepdu;
                            lle.newPackets = true;
                        } else {
                            System.out.println("Tossing packet: " + timestamp + " last: " + lle.espduTimestamp);
                        }
                    } else {
                        // create new entry
                        LiveListEntry newlle = new LiveListEntry(di, System.currentTimeMillis());
                        entry.listEntry = newlle;
                        newlle.lastEspdu = null;
                        newlle.currEspdu = null;
                        newlle.currDetonate = null;
                        newlle.currFire = firepdu;
                        newlle.espduTimestamp = timestamp;
                        newlle.closeEnough = false;
                        newlle.avgTime = 0.01f;
                        newlle.newPackets = true;

                        liveList.add(newlle);
                        di.setIsActive(true);
                    }

                } else {
                    System.err.println("Unknown entity: " + eid);
                }

                break;
//            case PduTypeField.DETONATIONFI:
            case DETONATION:
                DetonationPdu dpdu = (DetonationPdu) pdu;
                eid = dpdu.getTargetEntityID();
                disId.setValue(eid.getSite(), eid.getApplication(), eid.getEntity());

                entry = nodeMap.get(disId);

                if (entry == null) {
                    //System.out.println("Unknown espdu: " + disId);
                    return;
                }

                di = entry.node;

                if (di.getRole() != VRMLNetworkInterfaceNodeType.ROLE_READER) {
                    // Ignore for non readers
                    return;
                }

                time = System.currentTimeMillis();
                timestamp = pdu.getTimestamp();
                if (di != null) {
                    if (entry.listEntry != null) {
                        // update last time
                        LiveListEntry lle = (LiveListEntry) entry.listEntry;

                        if (timestamp > lle.espduTimestamp) {

                            lle.avgTime = lle.avgTime + (time - lle.lastTime) / 5.0f;
                            lle.lastTime = time;
                            if (lle.currEspdu != null) {
                                lle.lastEspdu = lle.currEspdu;
                            }
                            lle.currDetonate = dpdu;
                            lle.closeEnough = false;
                            lle.newPackets = true;
                        } else {
                            System.out.println("Tossing packet: " + timestamp + " last: " + lle.espduTimestamp);
                        }
                    } else {
                        // create new entry
                        LiveListEntry newlle = new LiveListEntry(di, System.currentTimeMillis());
                        entry.listEntry = newlle;
                        newlle.lastEspdu = null;
                        newlle.currEspdu = null;
                        newlle.currDetonate = dpdu;
                        newlle.espduTimestamp = timestamp;
                        newlle.closeEnough = false;
                        newlle.avgTime = 0.01f;
                        newlle.newPackets = true;

                        liveList.add(newlle);
                        di.setIsActive(true);
                    }

                } else {
//                    System.out.println("Unknown entity: " + eid);
                }

                break;
            case ENTITY_STATE:
                EntityStatePdu espdu = (EntityStatePdu) pdu;

                eid = espdu.getEntityID();

                disId.setValue(eid.getSite(), eid.getApplication(), eid.getEntity());

                entry = nodeMap.get(disId);

                if (entry == null) {
                    int len = managerList.size();

                    VRMLDISManagerNodeType manager;

                    for (int i = 0; i < len; i++) {
                        manager = (VRMLDISManagerNodeType) managerList.get(i);

                        if (!notifiedSet.contains(disId)) {
                            manager.entityArrived(espdu);

                            // Clone Id to put on list
                            notifiedSet.add((DISId) disId.clone());
                        }
                    }
                    return;
                }

                di = entry.node;

                if (di.getRole() != VRMLNetworkInterfaceNodeType.ROLE_READER) {
                    System.out.println("Ignoring ESPDU");
                    // Ignore for non readers
                    return;
                }

                time = System.currentTimeMillis();
                timestamp = pdu.getTimestamp();

                if (di != null) {
                    if (entry.listEntry != null) {
                        // update last time
                        LiveListEntry lle = (LiveListEntry) entry.listEntry;

                        if (timestamp > lle.espduTimestamp) {
                            lle.avgTime = lle.avgTime + (time - lle.lastTime) / 5.0f;
                            lle.lastTime = time;
                            lle.lastEspdu = lle.currEspdu;
                            lle.currEspdu = espdu;
                            lle.closeEnough = false;
                            lle.newPackets = true;
                        } else {
                            System.out.println("Tossing packet: " + timestamp + " last: " + lle.espduTimestamp);
                        }
                    } else {
                        // create new entry
                        LiveListEntry newlle = new LiveListEntry(di, System.currentTimeMillis());
                        entry.listEntry = newlle;
                        newlle.lastEspdu = espdu;
                        newlle.currEspdu = espdu;
                        newlle.rotationConverger = new OrderNQuat4dConverger(DEFAULT_ORDER, DEFAULT_CONVERGENCE_INTERVAL, null);
                        newlle.translationConverger = new OrderNVector3dConverger(DEFAULT_ORDER, DEFAULT_CONVERGENCE_INTERVAL, null);
                        newlle.espduTimestamp = timestamp;
                        newlle.closeEnough = false;
                        newlle.avgTime = 0.01f;
                        newlle.newPackets = true;

                        liveList.add(newlle);
                        di.setIsActive(true);
                    }

                } else {
                    //System.out.println("Unknown entity: " + eid);
                }

                break;
            default:
                System.err.println("Unhandled DIS node:  type: " + type + " " + pduType.getDescription());
        }
    }

} // end class file DISConnectionHandler.java
